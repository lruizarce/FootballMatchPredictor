"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.recursive=exports.object=exports.keyValuePairs=exports.record=exports.tuple=exports.array=exports.regex=exports.literalUnion=exports.oneOf=exports.literal=exports.boolean=exports.number=exports.string=exports.unknown=exports.nullable=exports.checkDefined=exports.DecoderError=exports.createDecoder=void 0;const createDecoder=decoder=>Object.assign(Object.assign({},decoder),{decode:data=>{try{return decoder.forceDecode(data)}catch(_a){return null}},validate:data=>{try{return{type:"ok",data:decoder.forceDecode(data)}}catch(e){if(e instanceof DecoderError){return{type:"error",error:e}}throw e}},is:data=>{try{decoder.forceDecode(data);return true}catch(_a){return false}},andThen:transformer=>{return exports.createDecoder({forceDecode:data=>transformer(decoder.forceDecode(data))})}});exports.createDecoder=createDecoder;class DecoderError extends SyntaxError{constructor(message){super(message);this.name="DecoderError";Object.setPrototypeOf(this,new.target.prototype)}}exports.DecoderError=DecoderError;const show=data=>JSON.stringify(data,null,2);const checkDefined=data=>{if(data==null)throw new DecoderError("This value is not there");return false};exports.checkDefined=checkDefined;const nullable=decoder=>exports.createDecoder({forceDecode:data=>data===null?null:decoder.forceDecode(data)});exports.nullable=nullable;const primitiveDecoder=(dataType,condition)=>exports.createDecoder({forceDecode:data=>{exports.checkDefined(data);if(!condition(data)){throw new DecoderError(`This is not ${dataType}: ${show(data)}`)}return data}});exports.unknown=exports.createDecoder({forceDecode:data=>data});exports.string=primitiveDecoder("a string",$=>typeof $==="string");exports.number=primitiveDecoder("a number",$=>typeof $==="number"&&Number.isFinite($));exports.boolean=primitiveDecoder("a boolean",$=>typeof $==="boolean");const literal=literal=>exports.createDecoder({forceDecode:data=>{exports.checkDefined(data);if(data!==literal){throw new DecoderError(`Data does not match the literal. Expected: '${literal}', actual value: '${show(data)}'`)}return data}});exports.literal=literal;const oneOf=(...decoders)=>exports.createDecoder({forceDecode:data=>{var _a;const errors=[];for(const decoder of decoders){try{return decoder.forceDecode(data)}catch(e){errors.push((_a=e.message)!==null&&_a!==void 0?_a:"Unknown error")}}throw new DecoderError(`None of the decoders worked:\n${show(errors)}`)}});exports.oneOf=oneOf;const literalUnion=(...decoders)=>exports.oneOf(...decoders.map(exports.literal));exports.literalUnion=literalUnion;const regex=regex=>exports.createDecoder({forceDecode:data=>{exports.checkDefined(data);if(!regex.test(data)){throw new DecoderError(`Data '${data}' does not satisfy the regex '${String(regex)}'.`)}return data}});exports.regex=regex;function checkArrayType(data){if(!Array.isArray(data))throw new DecoderError(`This is not an array: ${show(data)}`)}const array=decoder=>exports.createDecoder({forceDecode:data=>{exports.checkDefined(data);checkArrayType(data);return data.map(decoder.forceDecode)}});exports.array=array;const tuple=(...decoders)=>exports.createDecoder({forceDecode:data=>{exports.checkDefined(data);checkArrayType(data);if(decoders.length>data.length){throw new DecoderError(`The tuple is not long enough. ${decoders.length} > ${data.length}`)}return decoders.map((decoder,index)=>decoder.forceDecode(data[index]))}});exports.tuple=tuple;function checkDictType(data){if(typeof data!=="object"||data===null||Array.isArray(data)){throw new DecoderError(`This is not an object: ${show(data)}`)}else if(Object.keys(data).some($=>typeof $!=="string")){throw new DecoderError(`Not all keys in this object are strings: ${show(data)}`)}}const record=decoder=>exports.createDecoder({forceDecode:data=>{exports.checkDefined(data);checkDictType(data);return Object.fromEntries(Object.entries(data).map(([key,value])=>[key,decoder.forceDecode(value)]))}});exports.record=record;const keyValuePairs=decoder=>exports.createDecoder({forceDecode:data=>Object.entries(exports.record(decoder).forceDecode(data))});exports.keyValuePairs=keyValuePairs;const required=struct=>exports.createDecoder({forceDecode:data=>{checkDictType(data);const parsed={};for(const key in struct){if(data[key]===undefined)throw new DecoderError(`Object missing required property '${key}'`);parsed[key]=struct[key].forceDecode(data[key])}return parsed}});const partial=struct=>exports.createDecoder({forceDecode:data=>{checkDictType(data);const parsed={};for(const key in struct){if(data[key]!==undefined){parsed[key]=struct[key].forceDecode(data[key])}}return parsed}});const object=struct=>exports.createDecoder({forceDecode:data=>{exports.checkDefined(data);const result={};if(struct.required!==undefined){Object.assign(result,required(struct.required).forceDecode(data))}if(struct.optional!==undefined){Object.assign(result,partial(struct.optional).forceDecode(data))}return result}});exports.object=object;const recursive=decoder=>exports.createDecoder({forceDecode:data=>{return decoder().forceDecode(data)}});exports.recursive=recursive;