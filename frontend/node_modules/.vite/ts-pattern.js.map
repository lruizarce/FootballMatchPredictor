{
  "version": 3,
  "sources": ["../ts-pattern/lib/symbols.js", "../ts-pattern/lib/guards.js", "../ts-pattern/lib/wildcards.js", "../ts-pattern/lib/index.js", "dep:ts-pattern"],
  "sourcesContent": ["\"use strict\";\n/**\n * Symbols used internally within ts-pattern to construct and discriminate\n * Guard, Not, and Select, and AnonymousSelect patterns\n *\n * Symbols have the advantage of not appearing in auto-complete suggestions in\n * user defined patterns, and eliminate the admittedly unlikely risk of property\n * overlap between ts-pattern internals and user defined patterns.\n *\n * These symbols have to be visible to tsc for type inference to work, but\n * users should not import them\n * @module\n * @private\n * @internal\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AnonymousSelectKey = exports.Select = exports.Not = exports.Guard = exports.PatternKind = void 0;\n/** @internal This symbol should only be used by ts-pattern's internals. */\nexports.PatternKind = Symbol('@ts-pattern/pattern-kind');\n/** @internal This symbol should only be used by ts-pattern's internals. */\nexports.Guard = Symbol('@ts-pattern/guard');\n/** @internal This symbol should only be used by ts-pattern's internals. */\nexports.Not = Symbol('@ts-pattern/not');\n/** @internal This symbol should only be used by ts-pattern's internals. */\nexports.Select = Symbol('@ts-pattern/select');\nexports.AnonymousSelectKey = '@ts-pattern/__anonymous-select-key';\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.instanceOf = exports.select = exports.not = exports.when = void 0;\nconst symbols = require(\"./symbols\");\nconst when = (predicate) => ({\n    [symbols.PatternKind]: symbols.Guard,\n    [symbols.Guard]: predicate,\n});\nexports.when = when;\nconst not = (pattern) => ({\n    [symbols.PatternKind]: symbols.Not,\n    [symbols.Not]: pattern,\n});\nexports.not = not;\nfunction select(key) {\n    return key === undefined\n        ? {\n            [symbols.PatternKind]: symbols.Select,\n            [symbols.Select]: symbols.AnonymousSelectKey,\n        }\n        : {\n            [symbols.PatternKind]: symbols.Select,\n            [symbols.Select]: key,\n        };\n}\nexports.select = select;\nfunction isInstanceOf(classConstructor) {\n    return (val) => val instanceof classConstructor;\n}\nconst instanceOf = (classConstructor) => (0, exports.when)(isInstanceOf(classConstructor));\nexports.instanceOf = instanceOf;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.__ = void 0;\nconst guards_1 = require(\"./guards\");\nfunction isUnknown(x) {\n    return true;\n}\nfunction isNumber(x) {\n    return typeof x === 'number';\n}\nfunction numberIsNaN(x) {\n    return Number.isNaN(x);\n}\nfunction isString(x) {\n    return typeof x === 'string';\n}\nfunction isBoolean(x) {\n    return typeof x === 'boolean';\n}\nfunction isNullish(x) {\n    return x === null || x === undefined;\n}\nconst unknownGuard = (0, guards_1.when)(isUnknown);\nconst stringGuard = (0, guards_1.when)(isString);\nconst numberGuard = (0, guards_1.when)(isNumber);\nconst NaNGuard = (0, guards_1.when)(numberIsNaN);\nconst booleanGuard = (0, guards_1.when)(isBoolean);\nconst nullishGuard = (0, guards_1.when)(isNullish);\n/**\n * ### Catch All wildcard\n * `__` is wildcard pattern, matching **any value**.\n *\n * `__.string` is wildcard pattern matching any **string**.\n *\n * `__.number` is wildcard pattern matching any **number**.\n *\n * `__.NaN` is wildcard pattern matching **NaN**\n *\n * `__.boolean` is wildcard pattern matching any **boolean**.\n *\n * `__.nullish` is wildcard pattern matching **null** or **undefined**.\n * @example\n *  match(value)\n *   .with(__, () => 'will always match')\n *   .with(__.string, () => 'will match on strings only')\n *   .with(__.number, () => 'will match on numbers only')\n *   .with(__.NaN, () => 'will match on NaN')\n *   .with(__.boolean, () => 'will match on booleans only')\n *   .with(__.nullish, () => 'will match on null or undefined only')\n */\nexports.__ = Object.assign(unknownGuard, {\n    string: stringGuard,\n    number: numberGuard,\n    NaN: NaNGuard,\n    boolean: booleanGuard,\n    nullish: nullishGuard,\n});\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isMatching = exports.match = exports.instanceOf = exports.select = exports.not = exports.when = exports.__ = void 0;\nconst symbols = require(\"./symbols\");\nconst guards_1 = require(\"./guards\");\nObject.defineProperty(exports, \"when\", { enumerable: true, get: function () { return guards_1.when; } });\nObject.defineProperty(exports, \"not\", { enumerable: true, get: function () { return guards_1.not; } });\nObject.defineProperty(exports, \"select\", { enumerable: true, get: function () { return guards_1.select; } });\nObject.defineProperty(exports, \"instanceOf\", { enumerable: true, get: function () { return guards_1.instanceOf; } });\nconst wildcards_1 = require(\"./wildcards\");\nObject.defineProperty(exports, \"__\", { enumerable: true, get: function () { return wildcards_1.__; } });\n/**\n * #### match\n *\n * Entry point to create a pattern matching expression.\n *\n * It returns a `Match` builder, on which you can chain\n * several `.with(pattern, handler)` clauses.\n */\nconst match = (value) => builder(value, []);\nexports.match = match;\n/**\n * ### builder\n * This is the implementation of our pattern matching, using the\n * builder pattern.\n */\nconst builder = (value, cases) => {\n    const run = () => {\n        const entry = cases.find(({ test }) => test(value));\n        if (!entry) {\n            let displayedValue;\n            try {\n                displayedValue = JSON.stringify(value);\n            }\n            catch (e) {\n                displayedValue = value;\n            }\n            throw new Error(`Pattern matching error: no pattern matches value ${displayedValue}`);\n        }\n        return entry.handler(entry.select(value), value);\n    };\n    return {\n        with(...args) {\n            const handler = args[args.length - 1];\n            const patterns = [];\n            const predicates = [];\n            for (let i = 0; i < args.length - 1; i++) {\n                const arg = args[i];\n                if (typeof arg === 'function') {\n                    predicates.push(arg);\n                }\n                else {\n                    patterns.push(arg);\n                }\n            }\n            let selected = {};\n            const doesMatch = (value) => Boolean(patterns.some((pattern) => matchPattern(pattern, value, (key, value) => {\n                selected[key] = value;\n            })) && predicates.every((predicate) => predicate(value)));\n            return builder(value, cases.concat([\n                {\n                    test: doesMatch,\n                    handler,\n                    select: (value) => Object.keys(selected).length\n                        ? symbols.AnonymousSelectKey in selected\n                            ? selected[symbols.AnonymousSelectKey]\n                            : selected\n                        : value,\n                },\n            ]));\n        },\n        when: (predicate, handler) => builder(value, cases.concat([\n            {\n                test: predicate,\n                handler,\n                select: (value) => value,\n            },\n        ])),\n        otherwise: (handler) => builder(value, cases.concat([\n            {\n                test: () => true,\n                handler,\n                select: (value) => value,\n            },\n        ])).run(),\n        exhaustive: () => run(),\n        run,\n    };\n};\nconst isObject = (value) => Boolean(value && typeof value === 'object');\nconst isGuardPattern = (x) => {\n    const pattern = x;\n    return pattern && pattern[symbols.PatternKind] === symbols.Guard;\n};\nconst isNotPattern = (x) => {\n    const pattern = x;\n    return pattern && pattern[symbols.PatternKind] === symbols.Not;\n};\nconst isSelectPattern = (x) => {\n    const pattern = x;\n    return pattern && pattern[symbols.PatternKind] === symbols.Select;\n};\n// tells us if the value matches a given pattern.\nconst matchPattern = (pattern, value, select) => {\n    if (isObject(pattern)) {\n        if (isGuardPattern(pattern))\n            return Boolean(pattern[symbols.Guard](value));\n        if (isSelectPattern(pattern)) {\n            select(pattern[symbols.Select], value);\n            return true;\n        }\n        if (isNotPattern(pattern))\n            return !matchPattern(pattern[symbols.Not], value, select);\n        if (!isObject(value))\n            return false;\n        if (Array.isArray(pattern)) {\n            if (!Array.isArray(value))\n                return false;\n            // List pattern\n            if (pattern.length === 1) {\n                const selected = {};\n                const listSelect = (key, value) => {\n                    selected[key] = (selected[key] || []).concat([value]);\n                };\n                const doesMatch = value.every((v) => matchPattern(pattern[0], v, listSelect));\n                if (doesMatch) {\n                    Object.keys(selected).forEach((key) => select(key, selected[key]));\n                }\n                return doesMatch;\n            }\n            // Tuple pattern\n            return pattern.length === value.length\n                ? pattern.every((subPattern, i) => matchPattern(subPattern, value[i], select))\n                : false;\n        }\n        if (pattern instanceof Map) {\n            if (!(value instanceof Map))\n                return false;\n            return [...pattern.keys()].every((key) => matchPattern(pattern.get(key), value.get(key), select));\n        }\n        if (pattern instanceof Set) {\n            if (!(value instanceof Set))\n                return false;\n            if (pattern.size === 0)\n                return value.size === 0;\n            if (pattern.size === 1) {\n                const [subPattern] = [...pattern.values()];\n                return Object.values(wildcards_1.__).includes(subPattern)\n                    ? matchPattern([subPattern], [...value.values()], select)\n                    : value.has(subPattern);\n            }\n            return [...pattern.values()].every((subPattern) => value.has(subPattern));\n        }\n        return Object.keys(pattern).every((k) => k in value &&\n            matchPattern(\n            // @ts-ignore\n            pattern[k], \n            // @ts-ignore\n            value[k], select));\n    }\n    return value === pattern;\n};\nfunction isMatching(...args) {\n    if (args.length === 1) {\n        const [pattern] = args;\n        return (value) => matchPattern(pattern, value, () => { });\n    }\n    if (args.length === 2) {\n        const [pattern, value] = args;\n        return matchPattern(pattern, value, () => { });\n    }\n    throw new Error(`isMatching wasn't given enough arguments: expected 1 or 2, received ${args.length}.`);\n}\nexports.isMatching = isMatching;\n", "export default require(\"./node_modules/ts-pattern/lib/index.js\");"],
  "mappings": "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",
  "names": []
}
