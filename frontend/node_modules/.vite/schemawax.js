import {
  __commonJS
} from "./chunk-OZKD6XBJ.js";

// node_modules/schemawax/dist/index.js
var require_dist = __commonJS({
  "node_modules/schemawax/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recursive = exports.object = exports.keyValuePairs = exports.record = exports.tuple = exports.array = exports.regex = exports.literalUnion = exports.oneOf = exports.literal = exports.boolean = exports.number = exports.string = exports.unknown = exports.nullable = exports.checkDefined = exports.DecoderError = exports.createDecoder = void 0;
    var createDecoder = (decoder) => Object.assign(Object.assign({}, decoder), { decode: (data) => {
      try {
        return decoder.forceDecode(data);
      } catch (_a) {
        return null;
      }
    }, validate: (data) => {
      try {
        return { type: "ok", data: decoder.forceDecode(data) };
      } catch (e) {
        if (e instanceof DecoderError) {
          return { type: "error", error: e };
        }
        throw e;
      }
    }, is: (data) => {
      try {
        decoder.forceDecode(data);
        return true;
      } catch (_a) {
        return false;
      }
    }, andThen: (transformer) => {
      return exports.createDecoder({ forceDecode: (data) => transformer(decoder.forceDecode(data)) });
    } });
    exports.createDecoder = createDecoder;
    var DecoderError = class extends SyntaxError {
      constructor(message) {
        super(message);
        this.name = "DecoderError";
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
    exports.DecoderError = DecoderError;
    var show = (data) => JSON.stringify(data, null, 2);
    var checkDefined = (data) => {
      if (data == null)
        throw new DecoderError("This value is not there");
      return false;
    };
    exports.checkDefined = checkDefined;
    var nullable = (decoder) => exports.createDecoder({ forceDecode: (data) => data === null ? null : decoder.forceDecode(data) });
    exports.nullable = nullable;
    var primitiveDecoder = (dataType, condition) => exports.createDecoder({ forceDecode: (data) => {
      exports.checkDefined(data);
      if (!condition(data)) {
        throw new DecoderError(`This is not ${dataType}: ${show(data)}`);
      }
      return data;
    } });
    exports.unknown = exports.createDecoder({ forceDecode: (data) => data });
    exports.string = primitiveDecoder("a string", ($) => typeof $ === "string");
    exports.number = primitiveDecoder("a number", ($) => typeof $ === "number" && Number.isFinite($));
    exports.boolean = primitiveDecoder("a boolean", ($) => typeof $ === "boolean");
    var literal = (literal2) => exports.createDecoder({ forceDecode: (data) => {
      exports.checkDefined(data);
      if (data !== literal2) {
        throw new DecoderError(`Data does not match the literal. Expected: '${literal2}', actual value: '${show(data)}'`);
      }
      return data;
    } });
    exports.literal = literal;
    var oneOf = (...decoders) => exports.createDecoder({ forceDecode: (data) => {
      var _a;
      const errors = [];
      for (const decoder of decoders) {
        try {
          return decoder.forceDecode(data);
        } catch (e) {
          errors.push((_a = e.message) !== null && _a !== void 0 ? _a : "Unknown error");
        }
      }
      throw new DecoderError(`None of the decoders worked:
${show(errors)}`);
    } });
    exports.oneOf = oneOf;
    var literalUnion = (...decoders) => exports.oneOf(...decoders.map(exports.literal));
    exports.literalUnion = literalUnion;
    var regex = (regex2) => exports.createDecoder({ forceDecode: (data) => {
      exports.checkDefined(data);
      if (!regex2.test(data)) {
        throw new DecoderError(`Data '${data}' does not satisfy the regex '${String(regex2)}'.`);
      }
      return data;
    } });
    exports.regex = regex;
    function checkArrayType(data) {
      if (!Array.isArray(data))
        throw new DecoderError(`This is not an array: ${show(data)}`);
    }
    var array = (decoder) => exports.createDecoder({ forceDecode: (data) => {
      exports.checkDefined(data);
      checkArrayType(data);
      return data.map(decoder.forceDecode);
    } });
    exports.array = array;
    var tuple = (...decoders) => exports.createDecoder({ forceDecode: (data) => {
      exports.checkDefined(data);
      checkArrayType(data);
      if (decoders.length > data.length) {
        throw new DecoderError(`The tuple is not long enough. ${decoders.length} > ${data.length}`);
      }
      return decoders.map((decoder, index) => decoder.forceDecode(data[index]));
    } });
    exports.tuple = tuple;
    function checkDictType(data) {
      if (typeof data !== "object" || data === null || Array.isArray(data)) {
        throw new DecoderError(`This is not an object: ${show(data)}`);
      } else if (Object.keys(data).some(($) => typeof $ !== "string")) {
        throw new DecoderError(`Not all keys in this object are strings: ${show(data)}`);
      }
    }
    var record = (decoder) => exports.createDecoder({ forceDecode: (data) => {
      exports.checkDefined(data);
      checkDictType(data);
      return Object.fromEntries(Object.entries(data).map(([key, value]) => [key, decoder.forceDecode(value)]));
    } });
    exports.record = record;
    var keyValuePairs = (decoder) => exports.createDecoder({ forceDecode: (data) => Object.entries(exports.record(decoder).forceDecode(data)) });
    exports.keyValuePairs = keyValuePairs;
    var required = (struct) => exports.createDecoder({ forceDecode: (data) => {
      checkDictType(data);
      const parsed = {};
      for (const key in struct) {
        if (data[key] === void 0)
          throw new DecoderError(`Object missing required property '${key}'`);
        parsed[key] = struct[key].forceDecode(data[key]);
      }
      return parsed;
    } });
    var partial = (struct) => exports.createDecoder({ forceDecode: (data) => {
      checkDictType(data);
      const parsed = {};
      for (const key in struct) {
        if (data[key] !== void 0) {
          parsed[key] = struct[key].forceDecode(data[key]);
        }
      }
      return parsed;
    } });
    var object = (struct) => exports.createDecoder({ forceDecode: (data) => {
      exports.checkDefined(data);
      const result = {};
      if (struct.required !== void 0) {
        Object.assign(result, required(struct.required).forceDecode(data));
      }
      if (struct.optional !== void 0) {
        Object.assign(result, partial(struct.optional).forceDecode(data));
      }
      return result;
    } });
    exports.object = object;
    var recursive = (decoder) => exports.createDecoder({ forceDecode: (data) => {
      return decoder().forceDecode(data);
    } });
    exports.recursive = recursive;
  }
});

// dep:schemawax
var schemawax_default = require_dist();
export {
  schemawax_default as default
};
//# sourceMappingURL=schemawax.js.map
