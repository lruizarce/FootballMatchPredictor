import {
  __commonJS
} from "./chunk-OZKD6XBJ.js";

// node_modules/ts-pattern/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/ts-pattern/lib/symbols.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonymousSelectKey = exports.Select = exports.Not = exports.Guard = exports.PatternKind = void 0;
    exports.PatternKind = Symbol("@ts-pattern/pattern-kind");
    exports.Guard = Symbol("@ts-pattern/guard");
    exports.Not = Symbol("@ts-pattern/not");
    exports.Select = Symbol("@ts-pattern/select");
    exports.AnonymousSelectKey = "@ts-pattern/__anonymous-select-key";
  }
});

// node_modules/ts-pattern/lib/guards.js
var require_guards = __commonJS({
  "node_modules/ts-pattern/lib/guards.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.instanceOf = exports.select = exports.not = exports.when = void 0;
    var symbols = require_symbols();
    var when = (predicate) => ({
      [symbols.PatternKind]: symbols.Guard,
      [symbols.Guard]: predicate
    });
    exports.when = when;
    var not = (pattern) => ({
      [symbols.PatternKind]: symbols.Not,
      [symbols.Not]: pattern
    });
    exports.not = not;
    function select(key) {
      return key === void 0 ? {
        [symbols.PatternKind]: symbols.Select,
        [symbols.Select]: symbols.AnonymousSelectKey
      } : {
        [symbols.PatternKind]: symbols.Select,
        [symbols.Select]: key
      };
    }
    exports.select = select;
    function isInstanceOf(classConstructor) {
      return (val) => val instanceof classConstructor;
    }
    var instanceOf = (classConstructor) => (0, exports.when)(isInstanceOf(classConstructor));
    exports.instanceOf = instanceOf;
  }
});

// node_modules/ts-pattern/lib/wildcards.js
var require_wildcards = __commonJS({
  "node_modules/ts-pattern/lib/wildcards.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.__ = void 0;
    var guards_1 = require_guards();
    function isUnknown(x) {
      return true;
    }
    function isNumber(x) {
      return typeof x === "number";
    }
    function numberIsNaN(x) {
      return Number.isNaN(x);
    }
    function isString(x) {
      return typeof x === "string";
    }
    function isBoolean(x) {
      return typeof x === "boolean";
    }
    function isNullish(x) {
      return x === null || x === void 0;
    }
    var unknownGuard = (0, guards_1.when)(isUnknown);
    var stringGuard = (0, guards_1.when)(isString);
    var numberGuard = (0, guards_1.when)(isNumber);
    var NaNGuard = (0, guards_1.when)(numberIsNaN);
    var booleanGuard = (0, guards_1.when)(isBoolean);
    var nullishGuard = (0, guards_1.when)(isNullish);
    exports.__ = Object.assign(unknownGuard, {
      string: stringGuard,
      number: numberGuard,
      NaN: NaNGuard,
      boolean: booleanGuard,
      nullish: nullishGuard
    });
  }
});

// node_modules/ts-pattern/lib/index.js
var require_lib = __commonJS({
  "node_modules/ts-pattern/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMatching = exports.match = exports.instanceOf = exports.select = exports.not = exports.when = exports.__ = void 0;
    var symbols = require_symbols();
    var guards_1 = require_guards();
    Object.defineProperty(exports, "when", { enumerable: true, get: function() {
      return guards_1.when;
    } });
    Object.defineProperty(exports, "not", { enumerable: true, get: function() {
      return guards_1.not;
    } });
    Object.defineProperty(exports, "select", { enumerable: true, get: function() {
      return guards_1.select;
    } });
    Object.defineProperty(exports, "instanceOf", { enumerable: true, get: function() {
      return guards_1.instanceOf;
    } });
    var wildcards_1 = require_wildcards();
    Object.defineProperty(exports, "__", { enumerable: true, get: function() {
      return wildcards_1.__;
    } });
    var match = (value) => builder(value, []);
    exports.match = match;
    var builder = (value, cases) => {
      const run = () => {
        const entry = cases.find(({ test }) => test(value));
        if (!entry) {
          let displayedValue;
          try {
            displayedValue = JSON.stringify(value);
          } catch (e) {
            displayedValue = value;
          }
          throw new Error(`Pattern matching error: no pattern matches value ${displayedValue}`);
        }
        return entry.handler(entry.select(value), value);
      };
      return {
        with(...args) {
          const handler = args[args.length - 1];
          const patterns = [];
          const predicates = [];
          for (let i = 0; i < args.length - 1; i++) {
            const arg = args[i];
            if (typeof arg === "function") {
              predicates.push(arg);
            } else {
              patterns.push(arg);
            }
          }
          let selected = {};
          const doesMatch = (value2) => Boolean(patterns.some((pattern) => matchPattern(pattern, value2, (key, value3) => {
            selected[key] = value3;
          })) && predicates.every((predicate) => predicate(value2)));
          return builder(value, cases.concat([
            {
              test: doesMatch,
              handler,
              select: (value2) => Object.keys(selected).length ? symbols.AnonymousSelectKey in selected ? selected[symbols.AnonymousSelectKey] : selected : value2
            }
          ]));
        },
        when: (predicate, handler) => builder(value, cases.concat([
          {
            test: predicate,
            handler,
            select: (value2) => value2
          }
        ])),
        otherwise: (handler) => builder(value, cases.concat([
          {
            test: () => true,
            handler,
            select: (value2) => value2
          }
        ])).run(),
        exhaustive: () => run(),
        run
      };
    };
    var isObject = (value) => Boolean(value && typeof value === "object");
    var isGuardPattern = (x) => {
      const pattern = x;
      return pattern && pattern[symbols.PatternKind] === symbols.Guard;
    };
    var isNotPattern = (x) => {
      const pattern = x;
      return pattern && pattern[symbols.PatternKind] === symbols.Not;
    };
    var isSelectPattern = (x) => {
      const pattern = x;
      return pattern && pattern[symbols.PatternKind] === symbols.Select;
    };
    var matchPattern = (pattern, value, select) => {
      if (isObject(pattern)) {
        if (isGuardPattern(pattern))
          return Boolean(pattern[symbols.Guard](value));
        if (isSelectPattern(pattern)) {
          select(pattern[symbols.Select], value);
          return true;
        }
        if (isNotPattern(pattern))
          return !matchPattern(pattern[symbols.Not], value, select);
        if (!isObject(value))
          return false;
        if (Array.isArray(pattern)) {
          if (!Array.isArray(value))
            return false;
          if (pattern.length === 1) {
            const selected = {};
            const listSelect = (key, value2) => {
              selected[key] = (selected[key] || []).concat([value2]);
            };
            const doesMatch = value.every((v) => matchPattern(pattern[0], v, listSelect));
            if (doesMatch) {
              Object.keys(selected).forEach((key) => select(key, selected[key]));
            }
            return doesMatch;
          }
          return pattern.length === value.length ? pattern.every((subPattern, i) => matchPattern(subPattern, value[i], select)) : false;
        }
        if (pattern instanceof Map) {
          if (!(value instanceof Map))
            return false;
          return [...pattern.keys()].every((key) => matchPattern(pattern.get(key), value.get(key), select));
        }
        if (pattern instanceof Set) {
          if (!(value instanceof Set))
            return false;
          if (pattern.size === 0)
            return value.size === 0;
          if (pattern.size === 1) {
            const [subPattern] = [...pattern.values()];
            return Object.values(wildcards_1.__).includes(subPattern) ? matchPattern([subPattern], [...value.values()], select) : value.has(subPattern);
          }
          return [...pattern.values()].every((subPattern) => value.has(subPattern));
        }
        return Object.keys(pattern).every((k) => k in value && matchPattern(pattern[k], value[k], select));
      }
      return value === pattern;
    };
    function isMatching(...args) {
      if (args.length === 1) {
        const [pattern] = args;
        return (value) => matchPattern(pattern, value, () => {
        });
      }
      if (args.length === 2) {
        const [pattern, value] = args;
        return matchPattern(pattern, value, () => {
        });
      }
      throw new Error(`isMatching wasn't given enough arguments: expected 1 or 2, received ${args.length}.`);
    }
    exports.isMatching = isMatching;
  }
});

// dep:ts-pattern
var ts_pattern_default = require_lib();
export {
  ts_pattern_default as default
};
//# sourceMappingURL=ts-pattern.js.map
